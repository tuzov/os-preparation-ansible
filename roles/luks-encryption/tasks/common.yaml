#roles/luks-encryption/tasks/common.yaml
---
# assert variables and validate device
- name: Import assert.yaml
  import_tasks:
    file: assert.yaml
  when: device_type == "partition"

- name: Set device safe name
  set_fact:
    device_safe_name: "{{ target_device | regex_replace('/', '-') }}"

## blur the boundary between encrypted data and unencrypted data with shred

#### Key Management
# Create directory structure for keyfiles
- name: Create local secret directory
  file:
    path: "{{ item }}"
    state: directory
    mode: '0700'
  run_once: true
  delegate_to: localhost
  become: false
  loop: 
    - "{{ local_secret_dir }}"
    - "{{ local_secret_dir }}/{{ keyfiles_dir }}"
    - "{{ local_secret_dir }}/{{ headers_dir }}"

- name: Create remote secret directory in RAM
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: '0700'
  loop: 
    - "{{ remote_secret_dir }}"
    - "{{ remote_secret_dir }}/{{ keyfiles_dir }}"
    - "{{ remote_secret_dir }}/{{ headers_dir }}"

- name: Generate binary keyfile on the Ansible controller
  command: >
    dd if={{ keyfile_source_dev }} 
    of={{ keyfile_of }}
    bs={{ ( keyfile_size / 8) | int }} 
    count=1
    iflag=fullblock
  args:
    creates: "{{ keyfile_of }}"
  delegate_to: localhost
  vars:
    keyfile_of: "{{ local_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
  become: false

- name: Set permissions on local keyfiles
  delegate_to: localhost
  file:
    path: "{{ local_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
    mode: '0400'
  become: false
  
# check checksum if the same
- name: Copy keyfiles to remote system
  copy:
    src: "{{ local_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
    dest: "{{ remote_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
    mode: '0400'
    owner: root
    group: root
###
## select which cipher to pick 
- name: Check partition size
  shell: blockdev --getsize64 {{ target_device }}
  register: device_size
  changed_when: false
  failed_when: device_size.rc != 0

- name: Set appropriate cipher based on partition size
  set_fact:
    selected_keyfile_cipher: "{{ keyfile_cipher_light if (device_size.stdout|int < 10*1024*1024) else keyfile_cipher_default }}"
    luks_version: "{{ 'luks1' if (device_size.stdout|int < 10*1024*1024) else 'luks2' }}"

# encrypt the drive using the cryptsetup
- name: Create LUKS container (unchanged if exists)
  community.crypto.luks_device:
    device: "{{ target_device }}"
    state: present
    type: "{{ luks_version }}"
    cipher: "{{ selected_keyfile_cipher }}"
    keyfile: "{{ remote_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
    #passphrase: "{{ item.passphrase | default(omit) }}"  # noqa: args[module]
    #keyfile: "{{ item.keyfile | default(omit) }}"  # noqa: args[module]
  #no_log: true

# Find UUID of device
- name: Get LUKS UUID for device
  command: blkid -s UUID -o value {{ target_device }}
  register: device_uuid
  changed_when: false
  failed_when: device_uuid.rc != 0 or device_uuid.stdout == ""

- name: Update encryption_targets with UUIDs
  set_fact:
    device_uuid: "{{ device_uuid.stdout }}"

### add device to crypttab
- name: Add device to crypttab
  community.general.crypttab:
    name: "encrypted{{ device_safe_name }}"
    state: present
    password: "{{ remote_secret_dir }}/{{ keyfiles_dir }}/key-{{ ansible_hostname}}{{ device_safe_name }}"
    backing_device: "UUID={{ device_uuid }}"
    opts: cipher="{{ selected_keyfile_cipher }}"
  no_log: true

## start /etc/crypttab
- name: Start device mapper target
  command: cryptdisks_start "encrypted{{ device_safe_name }}"
  register: cryptdisks_start_results
  changed_when: "'started' in cryptdisks_start_results.stdout"
  failed_when: cryptdisks_start_results.rc != 0

- name: Check if device mapper target exists
  stat:
    path: "/dev/mapper/encrypted{{ device_safe_name }}"
  register: device_mapper_stats
  failed_when: not device_mapper_stats.stat.exists

### create filesystem ext4
- name: Create filesystem on LUKS devices
  filesystem:
    fstype: "{{ fstype }}"
    dev: "/dev/mapper/encrypted{{ device_safe_name }}"
  when: manage_filesystem and device_mapper_stats.stat.exists

## mount the drive
- name: Create mount directory
  file:
    path: "{{ target_name }}"
    state: directory
    owner: "{{ mount_owner | default(root) }}"
    group: "{{ mount_group | default(root) }}"
    mode: '0750'
  when: manage_filesystem and device_mapper_stats.stat.exists

- name: Check if target mount point exists
  stat:
    path: "{{ target_name }}"
  register: mount_point_stat
  when: manage_filesystem and device_mapper_stats.stat.exists and manage_mount

- name: Mount encrypted device
  mount:
    path: "{{ target_name }}"
    src: "/dev/mapper/encrypted{{ device_safe_name }}"
    fstype: "{{ fstype }}"
    state: mounted
  when: manage_filesystem and device_mapper_stats.stat.exists and manage_mount

## header backup

- name: Create temporary header backup on remote host
  command: >
    cryptsetup luksHeaderBackup {{ target_device }} 
    --header-backup-file {{ remote_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin
  when: header_backup
  register: header_backup_result
  changed_when: header_backup_result.rc == 0

- name: Set secure permissions on header backup file
  file:
    path: "{{ remote_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin"
    mode: '0400'
    owner: root
    group: root
  when: header_backup and header_backup_result.rc == 0

- name: Copy header backup to Ansible controller
  fetch:
    src: "{{ remote_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin"
    dest: "{{ local_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin"
    flat: yes
  when: header_backup and header_backup_result.rc == 0 

- name: Shred header backup on remote machine
  command: shred --remove --zero --iterations=5 "{{ remote_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin"
  args:
    removes: "{{ remote_secret_dir }}/{{ headers_dir }}/header-{{ ansible_hostname }}{{ device_safe_name }}.bin"
  when: header_backup and header_backup_result.rc == 0
  register: shred_result
  changed_when: shred_result.rc == 0
  failed_when: shred_result.rc != 0